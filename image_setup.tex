\label{sec:image_setup}
In this Section, we review the steps to create a common \ac{OS} image for
all the \ac{Raspi}s. The image setup is composed of three major steps:
Select and download the \ac{OS} image file, alter the image structure and
configure the \ac{OS} files. We proceed to detail all these steps providing
brief discussions to our setup choices when required. To perform these
steps, we indicate with command-line blocks the required sequential
commands to be typed by the testbed administrator in its \ac{PC} to obtain
the desired setting. In all the following sections, the number sign
(\#) and dollar sign (\$) will be used in the command blocks in the paper
to indicate if an operation needs to be run with root permissions or
common user permissions, respectively. The signs will be posted as the
terminal prompt in the command blocks.

\subsection{OS Selection and Download}

To get started, we first need to install an \ac{OS} that works properly
on all the \ac{Raspi} models. We will download and setup the image in
the testbed administrator \ac{PC} using a Debian-based distribution. We
use the popular Debian-based Raspbian Linux~\cite{raspbian} given that is
the recommended and default \ac{OS} for the \ac{Raspi}. Raspbian is made
available in two bundles: Raspbian and Raspbian lite. The difference
between the two, is that Raspbian contains a pre-installed desktop environment
for user interaction and Raspbian lite by default only permits to interact
through a command shell. Given that the \ac{Raspi}s in our testbed are not
connected to monitors, we decide to work with Raspbian lite. Still, if later
desired, a desktop environment can be installed using the package manager
as it will be shown in the configuration section.

% The overall procedure to customize the official Raspbian lite image
% are:
% \begin{enumerate}
%     \item Download Raspbian lite
%     \item Alter Raspbian lite. e.g. browse, modify, add, and delete files
%         in the official Raspbian lite image
%     \item Change root, i.e. change root filesystem into the Raspbian lite
%         image to update and install software packages
%     \item Write image to memory cards
% \end{enumerate}

%\subsection{Download Raspbian lite}
%To download the latest Raspbian lite, we go to the url
%\url{http://downloads.raspberrypi.org/raspbian_lite/images/}.

The latest Raspbian lite bundle can be downloaded from the Raspbian
official webpage~\cite{raspbian}. At the time of this writing, the latest
available bundle was \texttt{2016-05-27-raspbian-jessie-lite.zip}.
To ensure that the content of the bundle does not change, this procedure
is based on that particular version of Raspbian lite which we have
made available at~\cite{tunescode_webpage}. All other files used in this paper
are available there unless specified otherwise. To get started, the testbed
administrator must open a Linux shell (terminal) in and declare the environment
variables shown in the command block below. We show the procedure by
performing the role of the testbed administrator. To copy the commands from
this procedure to the testbed administrator terminal,
we strongly recommend to read this document with Adobe Acrobat Reader in Linux.
Otherwise, copied characters might not render properly.

%After the terminal has been opened, we start by declaring a few variables to reduce
%repeated typing. The first variables we declare is the Raspbian image name.
%Notice that the extension has been omitted. This is because the image has been
%packed into a zip file. The other variable we declare is a working directory.
%This is where we will download the image to and work on it. In other words, it
%will be stored in \texttt{/home/<username>/Raspbian}

%To download Raspbian lite, we go to the \url{http://downloads.raspberrypi.org}.
%There should be a folder called raspbian\lite and
%to find the download page at which Raspbian lite should be located. Instead of
%downloading with the browser, we just extract the download url to the latest
%image. At the time of this writing, that was

% Define variable]
\begin{lstlisting}[]
$ export URL="http://kom.aau.dk/project/TuneSCode/raspi/"
$ export IMAGE="2016-05-27-raspbian-jessie-lite"
$ export WORKDIR="${HOME}/Raspbian"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

In this code block, the \texttt{URL} and \texttt{IMAGE} variables specify where
the Linux bundle is located and \texttt{WORKDIR} specifies a working
directory where the Raspbian bundle will be downloaded and customized.
Notice that even though we use the \$ and \# signs in the shell, in general
these signs will be particular to the testbed administrator \ac{OS} shell.
Next, we create the working directory and go to it with the \texttt{cd}
command. To download the image, we utilize the \texttt{wget} command before
unpacking the \texttt{zip} file as follows:

% Running a command as root can on most systems be done by putting
% \texttt{sudo} in front of the command. This is illustrated in the
% following code block
% with the command \texttt{whoami} that prints the username. Lines within a code
% block without leading \$ or \# is terminal output or content of a file.

% Root example
% \begin{lstlisting}[]
% $ whoami
% <USERNAME>
% $ sudo whoami
% root
% \end{lstlisting}
% \FloatBarrier
% \vspace{-5mm}

% Download and unpack image
\begin{lstlisting}[]
$ mkdir -p ${WORKDIR}
$ cd ${WORKDIR}
$ wget ${URL%/*}/${IMAGE}.zip
$ unzip ${IMAGE}.zip
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

%A more recent version of Raspbian lite may be available at~\cite{raspbian}.
%\url{http://downloads.raspberrypi.org/raspbian_lite/images}.

\subsection{Image Customization}

After Raspbian lite has been unpacked, there should be an \texttt{.img}
file in the \texttt{WORKDIR} directory. Here, \texttt{fdisk} can be used to
display the content of the image. To do this and obtain administrative
information, we parse the arguments \texttt{-u sectors} to display the
sizes in sectors and \texttt{-l} to display the partitions within the
image. The \texttt{fdisk} command should output to the terminal something
similar to:

% Check out the image
% The dollar hack was to fix vim syntax
\begin{lstlisting}[literate={DOLLAR}{\$}1]
DOLLAR fdisk -u sectors -l ${IMAGE}.img
Disk 2016-05-27-raspbian-jessie-lite.img: 1.3 GiB, 1387266048 bytes, 2709504 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6fcf21f3

Device                               Boot  Start     End Sectors  Size Id Type
2016-05-27-raspbian-jessie-lite.img1        8192  137215  129024   63M  c W95 FAT32 (LBA)
2016-05-27-raspbian-jessie-lite.img2      137216 2709503 2572288  1.2G 83 Linux
\end{lstlisting}
\FloatBarrier

The output provides relevant information about the image. The image is in
total 2709504 sectors (1.3GiB) in size and contains two partitions. The
first partition starts at sector 8192 and the other partition starts at
sector 137216. The first partition type is FAT32 with a size of 63 MB
and the second partition is a Linux one with a size of 1.2 GB. This
indicates that the first partition is a boot partition and the second
one is a traditional Linux root filesystem, i.e. \texttt{/}.

\subsection{Image Resizing}
Given that we want to customize the files stored in the \ac{Raspi}s,
we need to resize the image file since 1.2GB might not be enough to store
the root filesystem due to the total size of the additional packages. Thus,
we need to increase the partition size. The following procedure illustrates
how the image and its root filesystem can be expanded by one \ac{GB}.
First, to expand the image one \ac{GB}, we execute:

\begin{lstlisting}[]
$ dd if=/dev/zero bs=1M count=1024 >> ${IMAGE}.img && sync
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Later, we use \texttt{fdisk} with the same arguments as before to see that
the image is now one \ac{GB} larger:
\begin{lstlisting}[literate={DOLLAR}{\$}1]
DOLLAR fdisk -u sectors -l ${IMAGE}.img
Disk 2016-05-27-raspbian-jessie-lite.img: 2.3 GiB, 2461007872 bytes, 4806656 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6fcf21f3

Device                               Boot  Start     End Sectors  Size Id Type
2016-05-27-raspbian-jessie-lite.img1        8192  137215  129024   63M  c W95 FAT32 (LBA)
2016-05-27-raspbian-jessie-lite.img2      137216 2709503 2572288  1.2G 83 Linux
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now, in this command block output, we observe that the change has taken
effect by noticing the total available image size is 2.3GiB. To expand the
root filesystem, it is required to first remove the Linux partition
and then add it again with one \ac{GB} more. To do this, we make use
again of \texttt{fdisk} in command mode to alter the partition table.
For this, we pass the arguments of the command mode of \texttt{fdisk}
through the \texttt{echo} command in Linux and the \texttt{|} operator
(pipe) as follows:

\begin{lstlisting}[]
$ (echo d; echo 2; echo n; echo ; echo ; echo 137216; echo ; echo w) | fdisk ${IMAGE}.img
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The \texttt{echo} commands within the parenthesis are interpreted as
key-presses in the \texttt{fdisk} commmand mode. They (i) delete partition
number 2, (ii) create a new primary type partition by default, (iii) set the
new partition starting point (137216) and (iv) write new partition table to
the image file. The previously shown command options of \texttt{fdisk}
should work for both old and new versions of the commands. However, if this
is not the case, the testbed administrator can do these commands manually.
In this case, it is only required to delete the old root
filesystem partition and create the new one starting from the same sector
number. In our case, if the partitions commands were correct, the output
should be following:

\begin{lstlisting}[]

Command (m for help): Partition number (1-4):
Command (m for help): Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): Using default response p
Partition number (1-4, default 2): Using default value 2
First sector (2048-4806655, default 2048): Last sector, +sectors or
+size{K,M,G} (137216-4806655, default 4806655): Using default value 4806655

Command (m for help): The partition table has been altered!

Syncing disks.

\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\subsection{Loopback Device Setup}
After successfully resizing the image file, we use a loopback device to make
the Raspbian image available as a block device in the filesystem. For this
command to work, the tested administrator distribution must have the
\texttt{util-linux} package with version 2.21 or higher. Otherwise, the
\texttt{-P} argument of \texttt{losetup} will appear as invalid.


\begin{lstlisting}[]
# export DEV=$(sudo losetup --show -f -P ${IMAGE}.img); echo $DEV
/dev/loop0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

If the previous command was succesful, the \texttt{lsblk} command can be used
to list the available block devices in the filesystem as follows:
%Use \texttt{lsblk} to view the partitions:

\begin{lstlisting}[]
# lsblk
NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
...
loop0       7:0    0  2.3G  0 loop
|-loop0p1 259:2    0   63M  0 loop
|-loop0p2 259:3    0  2.2G  0 loop
...
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The image block device appears as \texttt{/dev/loop0}. This block device has
two partitions associated to it, e.g. \texttt{loop0p1} and \texttt{loop0p2}.
Finally, we check the block device status with \texttt{e2fsck} and
\texttt{resize2fs}, respectively in the command block:

\begin{lstlisting}[]
# e2fsck -f ${DEV}p2
e2fsck 1.42.8 (20-Jun-2013)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/dev/loop0p2: 35392/80480 files (0.1% non-contiguous), 201968/321536 blocks
# resize2fs ${DEV}p2
resize2fs 1.42.8 (20-Jun-2013)
Resizing the filesystem on /dev/loop0 to 583680 (4k) blocks.
The filesystem on /dev/loop0 is now 583680 blocks long.
\end{lstlisting}
\FloatBarrier

\subsection{Block Devices Mounting}
For browsing and altering the files in the image, we mount the block
device partitions into a particular path of our \texttt{WORKDIR} in order
to customize them. We proceed first to mount the block device partition that
contains the root filesystem and later the boot partition. This is done by
creating an empty directory that it is used as a mountpoint. We name it
\texttt{root} and create it in the working directory before mounting the
root filesystem onto the mountpoint. Thus, we mount the root filesystem
as follows:

\begin{lstlisting}[]
$ export ROOTDIR="${WORKDIR}/root"
$ mkdir -p ${ROOTDIR}
# mount ${DEV}p2 ${ROOTDIR}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
%# mount -o loop,offset=$((137216*512)) ${IMAGE}.img ${ROOTDIR}

The root filesystem mounted in \texttt{ROOTDIR}, has already a boot
directory that can be used as the mount point for the boot partition
in the block device \texttt{loop0p1}. This is convenient because
the final edited partition from \texttt{ROOTDIR/boot} will be mounted on
this same directory when a \ac{Raspi} starts up with a memory card
containing the raw final image. Hence, to mount boot partition we do:
%It is therefore the natural place to mount it for later purposes.

\begin{lstlisting}[]
# mount ${DEV}p1 ${ROOTDIR}/boot
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
%# mount -o loop,offset=$((8192*512)) ${IMAGE}.img ${ROOTDIR}/boot
%We can now change all the files in the disk image as desired.

In this way, it is now possible to change all files within the Raspbian
image as desired by editing the files in \texttt{ROOTDIR}. We take
advantage of this to edit configuration files, append new files and even
update and install packages.

\subsection{Default OS Files and Configuration Scripts Setup}

In general, the \ac{Raspi}s should be setup as similar as possible. However,
some particularities exist to differentiate the devices in principle. Also,
scripts containing further configurations for the \ac{Raspi}s are desirable
to be distributed as part of the common image. Therefore, here we present
the steps to setup basic properties of the \ac{Raspi}s and distributing
configuration scripts to each of them through the image. First, we indicate
how to obtain and put our configuration scripts in the image. Later, we
describe the tasks performed by these configuration scripts. Nevertheless,
any testbed administrator might modify or include other tasks besides the
presented in this procedure according to his / her needs.

In our case, we have our configuration scripts are stored in a \texttt{.zip}
file located in a web server. We first retrieve this compressed file with
\texttt{wget} and unzip it locally into our Raspbian lite image. These
commands and the output of the last one are shown as follows:

% Get the configuration files that are compressed in a remote server
\begin{lstlisting}[]
$ wget ${URL%/*}/rasp_config.zip
$ unzip rasp_config.zip -d ${ROOTDIR}/home/pi/
Archive:  rasp_config.zip
   creating: ${ROOTDIR}/home/pi/rasp_config/
  inflating: ${ROOTDIR}/home/pi/rasp_config/nodes.csv
  inflating: ${ROOTDIR}/home/pi/rasp_config/set_hostname
  inflating: ${ROOTDIR}/home/pi/rasp_config/main
  inflating: ${ROOTDIR}/home/pi/rasp_config/update_rasp_config
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now,

Among the settings that we want to be different in the devices is
their hostname. The hostname helps the user to physically distinguish the
devices from each other. Thus, in our case we require the devices in our
testbed to have different hostnames. Moreover, besides this standard task,
other testbed administrators may need to also include other scripts to
configure their \ac{Raspi}s. Hence, we want to ensure that all the \ac{Raspi}
configuration scripts of any testbed administrators are obtained in a simple
way. Therefore, we ease this task by making the \ac{Raspi}s fetch the
configuration scripts during start up before running them.

Hence, we define the hostnames based on the \ac{MAC} addresses
of the \ac{Raspi}s wired Ethernet interface. Prior to this stage, the
\ac{MAC} address of a network card can be found using the command
\texttt{ifconfig} or \texttt{ip addr} on a given \ac{Raspi}.
We store the \ac{MAC} addresses and hostnames of the \ac{Raspi}s in the
configuration file \texttt{\${ROOTDIR}/home/pi/rasp\_config/nodes.csv} as
shown:

% MAC and Hostname file
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/home/pi/rasp\_config/nodes.csv}@>
<@\textcolor{gray}{
--------------------------------------------------------------------------------}
\Reactivatenumber @>
# Ethernet MAC    Hostname
b8:27:eb:5b:da:20 rasp00
b8:27:eb:7b:c3:91 rasp01
b8:27:eb:54:9c:64 rasp02
b8:27:eb:95:bd:11 rasp03
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The testbed administrator has to insert the \ac{MAC} addresses and hostnames
of his/her \ac{Raspi}s obtained previously in the format shown in the
configuration file. Once we have defined the hostnames in
\texttt{\${ROOTDIR}/home/pi/rasp\_config/nodes.csv}, we use the following
\ac{Bash} script to have each \ac{Raspi} assign its hostname:

% Set hostname
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/home/pi/rasp\_config/set\_hostname}@>
<@\textcolor{gray}{
-------------------------------------------------------------------------------------}
\Reactivatenumber @>
#!/usr/bin/env bash

script_path="$(dirname $(realpath $0))"
config_file=${script_path}/nodes.csv
mac=$(cat /sys/class/net/eth0/address)
old_hostname=$(hostname)
new_hostname=$(grep $mac $config_file | cut -f2 -d' ')

# Assign hostname found in nodes.csv
if [ ! -z ${new_hostname} ]; then
    echo ${new_hostname} > /etc/hostname
    hostname ${new_hostname}
    sed -i.old -e "s:${old_hostname}:${new_hostname}:g" /etc/hosts
fi
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The \texttt{\$\{ROOTDIR\}/home/pi/rasp\_config/set\_hostname} script (in
script lines): (1) tells the system to interpret the script using \ac{Bash},
(3-4) gets the path to the script itself and the list of hostnames, (5) gets
the \ac{MAC} address of the node itself, (6) gets the current hostname, (7)
gets the new hostname from the hostname list and (10-14) assigns the new
hostname to the \ac{Raspi} where the script will be executed.

It is likely that the testbed administrator needs to either change or add
scripts to configure the \ac{Raspi}s. This would be tedious to distribute to
all \ac{Raspi}s at a later stage. We ease this task by making the \ac{Raspi}s fetch the
configuration scripts during start up before running the configuration scripts.

The below script attempts to download/update the scripts:

\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/home/pi/rasp\_config/update\_rasp\_config}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
#!/usr/bin/env bash

url="http://kom.aau.dk/project/TuneSCode/raspi/"
config_file="rasp_config.zip"

# Attempt to fetch new configuration files
if ! wget -q --show-progress -O /tmp/${config_file} ${url%/}/${config_file}; then
    echo "Warning: Unable to update rasp_config files"
    exit 1
fi

# Unzip and overwrite configurationn files to root's home directory
unzip -q -o /tmp/${config_file} -d /home/pi/
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\begin{itemize}
    \item Line 3-4: Is the url and zip file that should be downloaded
    \item Line 7-10: Downloads the new configuration files to \texttt{/tmp}
        and prints a warning in case of errors
    \item Line 13: Unzips the files to \texttt{/home/pi/} while ignoring existing files/directories
\end{itemize}



For the above scripts to work in the \ac{Raspi}s, it is required that the \ac{Raspi}
\ac{MAC} address is found in \texttt{nodes.csv}. Thus,
\texttt{rasp\_config.csv} needs to be unzipped, altered, and zipped again in
the \ac{HTTP} server from which the \ac{Raspi} retrieves the files from.
The testbed administrator will therefore need to also edit the \ac{URL} in the
script \texttt{update\_rasp\_config}.
%"nodes.csv" can be changed using a text editor. For vim, this could be done
%the following way:
%\begin{lstlisting}[]
%$ vim ${ROOTDIR}/home/pi/rasp_config/nodes.csv
%\end{lstlisting}
%\FloatBarrier
%\vspace{-5mm}

Finally, to actually make the \ac{Raspi}s change hostname, we have to make
each \ac{Raspi} call the above script when it starts up. Optionally,
also run the update script before running other scripts.
Do this with root permissions by inserting the line(s) below before
\texttt{"exit 0"} using your favorite editor:
%"\$\{ROOTDIR\}/etc/rc.local" using
%your favorite text editor..
%The file
%can be opened with your favorite text editor.

\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/etc/rc.local}@>
<@\textcolor{gray}{
-----------------------------------------------------}
\Reactivatenumber @>
...
bash /home/pi/rasp_config/update_rasp_config
bash /home/pi/rasp_config/set_hostname
...
exit 0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Configuring \texttt{rc.local} makes it really cumbersome for the testbed
administrator to add new scripts since it first needs to be included
in \texttt{rasp\_config.zip} and then each \ac{Raspi} needs to have an additional
line added to \texttt{rc.local} in the root image or in all memory cards depending on
the final testbed setup.

A solution to this is to make yet another script in \texttt{rasp\_config.zip}
that calls all the other scripts in the desired order. This would look like
below:
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/home/pi/rasp\_config/main}@>
<@\textcolor{gray}{
-----------------------------------------------------}
\Reactivatenumber @>
#!/usr/bin/env bash

bash /home/pi/rasp_config/set_hostname
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now, to use the above script, \texttt{rc.local} needs to look like this:
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{ROOTDIR\}/etc/rc.local}@>
<@\textcolor{gray}{
-----------------------------------------------------}
\Reactivatenumber @>
...
bash /home/pi/rasp_config/update_rasp_config
bash /home/pi/rasp_config/main
...
exit 0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
Notice that \texttt{set\_hostname} is now called by the \texttt{main}
script instead. The update script is still called directly. This ensures that
all configuration scripts are updated before executed. Changes to the update
script itself will first take effect at next system startup.
%Had the update script
%been called in \texttt{main} instead would mean that changes to the
%\texttt{main} script would also first have been available at next startup.

%This can be done by inserting a call to the script
%set\_hostname in rc.local before it exits.
%
%Call set\_hostname script at startup. We insert a line of code to call script in rc.local just after the initial comments (i.e. lines starting with \#).
%\begin{lstlisting}[]
%# line_number=$(egrep -n -m1 "(^[^#])|(^$)" ${ROOTDIR}/etc/rc.local | cut -d: -f1)
%# sed -i "${line_number}c bash /home/pi/rasp_config/set_hostname" ${ROOTDIR}/etc/rc.local
%\end{lstlisting}
%\FloatBarrier
%$ line="bash /home/pi/.rasp_config/set_hostname"
%# awk -v text="$line" '!/^#/ && !p {print text; p=1} 1' ${ROOTDIR}/etc/rc.local > <@ \Suppressnumber @>
%    ${ROOTDIR}/etc/rc.local <@ \Reactivatenumber @>

%WE NEED TO ADD A FEW COMMANDS TELLING HOW TO ZIP, MODIFY, AND UNZIP
%FOR THE READER TO BE ABLE TO UPLOAD A CONSTRUCT HIS/HER OWN BUNDLE.

%All other files could be updated as well.
It is not only possible to add and configure files to/within the image. One can
also install and update the packages within the image which will be illustrated
in the next section.

\subsection{Installing and updating the image}

It may be desired to pre-install some programs in the image before it is
written to all the memory cards that goes into the \ac{Raspi}s.
This can be done from any linux x86 machine using QEMU Chroot~\cite{QemuUserEmulation}
(change root).
%\url{https://wiki.debian.org/QemuUserEmulation}
%\url{https://wiki.archlinux.org/index.php/Raspberry_Pi}

Due to the \ac{ARM} processor that \ac{Raspi}s are using, it is required to
install some additional software:
%Because \ac{Raspi}s are equipped with an \ac{ARM} processor
%%it is not as
%straightforward as performing the task for two Linux systems of the same
%architecture.

% CHROOT to OS image
\begin{lstlisting}[]
# apt-get install binfmt-support qemu qemu-user-static
# update-binfmts --display qemu-arm
qemu-arm (enabled):
     package = qemu-user-static
        type = magic
      offset = 0
       magic = \x7fELF\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x28\x00
        mask = \xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff
 interpreter = /usr/bin/qemu-arm-static
    detector =
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
% This was neccessary on arch
%# update-binfmts --importdir /var/lib/binfmts/ --import

Make sure the second command writes "enabled" as the output above. If that
is not the case, then try enabling it:

\begin{lstlisting}[]
# update-binfmts --enable qemu-arm
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Provided that qemu-arm is enabled, we should now be able to change root (chroot)
into our Raspbian lite image. Change root is a method in Linux that enables
the root (/) to be changed. Thus, enabling a Linux installation within a
Linux installation.

There are a few commands to be performed before actually changing root into the
root partion of the image.
First, to get internet access from within the Raspbian lite image it is needed
to copy our \texttt{resolv.conf} into the filesystem. Line 1 change directory
into root filesystem of the image. The second line copies \texttt{resolv.conf}
from the testbed administrators \ac{PC} to the image.

% CHROOT to OS image
\begin{lstlisting}[]
$ cd $ROOTDIR
# cp /etc/resolv.conf ${ROOTDIR}/etc/resolv.conf
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now, because of the \ac{ARM} architecture,
\texttt{/usr/bin/qemu-arm-static} needs to be copied into the image before continuing:

% CHROOT to OS image
\begin{lstlisting}[]
# cp /usr/bin/qemu-arm-static ${ROOTDIR}/usr/bin
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The final preparation before changing root is to populate the directories \texttt{proc},
\texttt{sys}, and \texttt{dev}:

% CHROOT to OS image
\begin{lstlisting}[]
# mount  -t proc proc proc/
# mount --bind /sys sys/
# mount --bind /dev dev/
# mount --bind /dev/pts dev/pts
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Finally, it is time to change root.
%Finally, the filesystem is ready for us to change root.
This can be done with \texttt{proot}. It may be required to install
\texttt{proot} using \texttt{apt-get install proot}:

% CHROOT to OS image
\begin{lstlisting}[]
# proot -q qemu-arm-static -S ${ROOTDIR}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Most available material online uses the more known \texttt{chroot} command as
written in the code block below instead of \texttt{proot}. This did not work
correctly in our machines, but we present the command as an alternative to
\texttt{proot} in case the testbed administrator should be in the opposite
situration where \texttt{proot} is not working.

% CHROOT to OS image
\begin{lstlisting}[]
# chroot ${ROOTDIR} /usr/bin/qemu-arm-static /bin/bash    (ALTERNATIVE TO proot)
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

If everything went well, we should now be \texttt{chrooted} into the Raspbian lite
filesystem under its root. Optionally, change the prompt title to indicate that it
is a \texttt{chrooted} environment:

% Optionally, we may create a unique prompt to indicate we have changed root
\begin{lstlisting}[]
# export PS1="(chroot) $PS1"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The Raspbian lite system image should now be possible to use almost as if it
had been booted in a \ac{Raspi}.
A major difference is that the testbed administrator's \ac{PC} is likely
significantly faster than a \ac{Raspi}.
%The only difference is that the laptop that we are using is
%significantly faster than a \ac{Raspi}.
Thus enabling updates, upgrades, and installing new software packages much
faster than in the \ac{Raspi}s.
%Thus enabling us to for example update,
%upgrade, and install software packages:

% Update system
\begin{lstlisting}[]
(chroot) # apt-get update
(chroot) # apt-get upgrade
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

We also install a few packages that we find useful:
%Lets install some useful applications:
% Install packages
\begin{lstlisting}[]
(chroot) # apt-get install vim git screen
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

When writing the image to a memory card, all these change that has been made
to the image so far will exists in all \ac{Raspi}s.
%All the changes that are made here will exists in all \ac{Raspi}s when the
%image is written to a memory card.