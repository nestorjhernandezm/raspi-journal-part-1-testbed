%!TEX root = raspi_journal.tex
% At the beginning, there was darkness and then... bang! \ac{NC}
% \cite{ahlswede2000network} appeared to save us from the evilness
% of routing.
%
% General introduction. Introduction to topic addressed in the journal.
% Review of the State of the Art. Specify why our approach has benefits
% and which are they. Indicate contributions.

The upcoming 5G technology is targeting the controlling and steering of the \ac{IoT} in real-time on a global scale. This will break new ground for new markets such as driverless vehicles, manufacturing, humanoid robots, and smart grids. The number of wireless devices is expected to increase by five times up to 50 billion devices \cite{cisco2011forecast}. It is generally believed, that those devices will not be connected in the same manner as current devices are connected today. Centralized system will collapse in terms of capacity, while distributed systems appear as an alternative. Therefore the communication architecture in future systems will be dominated by mesh technologies. Mesh technology has been known for sensor and ad hoc networks or mobile cloud scenarios, but the technical requirements on 5G mesh-based communication systems are dramatically increasing. Future mesh networks need to support high data rate, low latency, security, network availability and heterogeneous devices to ensure high \ac{QoE} for the final user. In state of the art systems those requirements are traded-off with each other, but in the 5G context we cannot do this anymore.

Introduced by Ahlswede et al. \cite{ahlswede2000network}, network coding constitutes a paradigm shift in the way how researchers and industry understand and operate networks, by changing the role of intermediate relays in the process of transmission of information. Relays are no longer limited to storing and forwarding data, but also take part in the coding process, through a process called recoding, where the relay generates new linear combinations of incoming coded packets without previously decoding the data. Network coding allows the increase of throughput, reliability, security and delay performance of the networks. In previous works, we have shown that \ac{RLNC} \cite{koetter2003algebraic,ho2006random} is able to satisfy the aforementioned technical requirements. We have actually shown how to increase the throughput \cite{pahlevani2013playncool}, reduce the delay \cite{szabo2015towards} or support heterogeneity for coding enabled communication nodes \cite{lucani2014fulcrum}.

In our prior works, the C++11 Kodo library \cite{kodo2011pedersen} was used as the common building block containing the basic \ac{RLNC} functionalities. Most of the work was focusing on small mesh networks with a handful of communication nodes, though the expected scenarios are fairly beyond this order of magnitude. Despite this successful deployment in real systems, many of these protocols and contributions have been implemented in separate testbeds and the experiences are hard to reproduce. Deploying a large-scale and configurable testbed for networking and storage can be challenging, not only due to the inherent costs of the hardware, but due to maintenance challenges and ability to replicate results consistently. The latter requires not only the devices to run the same \ac{OS}, but also have exactly the same configurations and software packages. There is a need in evaluating large scale network deployments of low cost devices in a quick, easy-to-deploy, reproducible and maintainable fashion.

The emergence of powerful and inexpensive single-board computers running full versions of a standard \ac{OS} from many possible opens new possibilities in this area. This not only allows to seamlessly develop implementations that are compatible with higher end devices, but also permits the reuse of stable software from widely-used \ac{OS}. For example, the work in \cite{cox2014iridis} provides a detailed description of a \ac{Raspi}~\cite{making_of_pi} testbed ideal for educational applications. Here the authors present computational speed benchmarks, inter-node communication throughput and memory card writing speeds for data storage to assess the testbed performance. However, this work indicates only a basic description of how to set up the required software and also mentions that its maintenance could be time-demading. Moreover, this work does not consider possible network coding applications. Different studies of \ac{IoT} applications consider using the \ac{Raspi} for data processing: In \cite{leccese2014smartcity}, the \ac{Raspi} is the processing unit that coordinates and controls the activity of a public road isle of lamps and reports it to a monitoring center. A use case regarding remote environment surveillance is presented in \cite{leccese2014newimaging}, where the \ac{Raspi} reports air pressure, humidity and temperature of the locations of cultural paintings plus high-resolution images of the paintings themselves. This data is sent to a monitoring center to ensure the preservation of the paintings. Further, authors in \cite{sapes2016finger} utilize the \ac{Raspi} to act as the data server in a finger scanning application that collects the fingerprints. Even though all these applications consider the use of the \ac{Raspi} as a core block, they provide few to no description of their procedures to configure the \ac{Raspi}. Moreover, these applications become cumbersome to maintain as their considered systems could potentially scale when aiming to serve more users. The current way that the data is sent in the considered networks for these \ac{IoT} applications will not be feasible in future 5G systems as mentioned previously.

Given this set of specific needs, in this work we present the design, key step-by-step instructions and mechanisms to setup, configure and maintain an inexpensive testbed using potentially several \ac{Raspi} devices for networking (wireless or wired) and storage applications including \ac{RLNC} functionalities into the testbed through Kodo. The architecture itself is not bounded to the networking area and can be used for other applications that require replicable results with the \ac{Raspi}. Our work for the testbed procedure is organized as follows: Section~\ref{sec:overview} introduces the testbed system. In Section~\ref{sec:image_setup}, we provide details about the testbed setup, scripts, configuration files and connectivity. In Section~\ref{sec:overlay_fs}, we elaborate on the need and setup for an overlay filesystem for our testbed in order to have both persistent and non-persistent data on it as an optional step. Section~\ref{sec:tools} describes a set of automation and monitoring tools that can be included in the testbed to simplify the execution of routinary and repetitive tasks. Section~\ref{sec:cross_compilation} elaborates on the compilation of the Kodo library for the \ac{Raspi}. Conclusions and future work are reviewed in Section~\ref{sec:conclusions}. Finally, a set of alternative commands, in case the ones presented in this work might not be executed, are discussed in the Appendices.

%%The introduction should briefly place the study in a broad context and highlight why it is important. It should define the purpose of the work and its significance. The current state of the research field should be reviewed carefully and key publications should be cited. Please highlight controversial and diverging hypotheses when necessary. Finally, briefly mention the main aim of the work and highlight the main conclusions. As far as possible, please keep the introduction comprehensible to scientists outside your particular field of research.
