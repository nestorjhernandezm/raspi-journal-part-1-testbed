%!TEX root = raspi_journal.tex
% At the beginning, there was darkness and then... bang! \ac{NC}
% \cite{ahlswede2000network} appeared to save us from the evilness
% of routing.
%
% General introduction. Introduction to topic addressed in the journal.
% Review of the State of the Art. Specify why our approach has benefits
% and which are they. Indicate contributions.

The upcoming 5G technology is targeting the controlling and steering of the Internet of Things (IoT) in real-time on global scale. This will break new ground for new markets such as driverless vehicles, manufacturing, humanoid robots, smart grids, and many more. With 5G, the number of wireless devices will increase by five times up to 50 billion devices \cite{cisco2011forecast}. It is generally believed, that those devices will not be connected in the same manner as current devices are connected today. Centralized system will collapse in terms of capacity, while distributed systems appear as an alternative. Therefore the communication architecture in future systems will be dominated by mesh technologies. Mesh technology has been known for sensor and ad hoc networks or mobile cloud scenarios, but the technical requirements on 5G mesh-based communication systems are dramatically increasing. Future mesh networks need to support high data rate, low latency, security, network availability and heterogeneous devices. In state of the art systems those requirements are traded-off with each other, but in the 5G context we cannot do this anymore.

Introduced by Ahlswede et al. \cite{ahlswede2000network}, network coding constitutes a paradigm shift in the way how researchers and industry understand and operate networks, by changing the role of intermediate relays in the process of transmission of information. Relays are no longer limited to storing and forwarding data, but also take part in the coding process, through a process called recoding, where the relay generates new linear combinations of incoming coded packets without previously decoding the data. Network coding allows the increase of throughput, reliability, security and delay performance of the networks. In our previous works, we have shown that \ac{RLNC} \cite{koetter2003algebraic,ho2006random} is able to satisfy the aforementioned technical requirements. We have actually shown how to increase the throughput \cite{pahlevani2013playncool}, reduce the delay \cite{szabo2015towards} or support heterogeneity for coding enabled communication nodes \cite{lucani2014fulcrum}.

In all these prior works, the C++11 Kodo library \cite{kodo2011pedersen} was used as the common building block containing the basic \ac{RLNC} functionalities. However, most of the work was focusing on small mesh networks with a handful of communication nodes, though the expected scenarios are fairly beyond this order of magnitude. Moreover, despite this successful deployment in real systems, many of these protocols and contributions have been implemented in separate testbeds and the experiences are hard to reproduce. Furthermore, deploying a large-scale and configurable testbed for networking and storage can be challenging, not only due to the inherent costs of the hardware, but due to maintenance challenges and ability to replicate results consistently. The latter requires not only the devices to run the same \ac{OS}, but also have exactly the same configurations and software packages. Hence, there is a need in evaluating large scale network deployments of low cost devices in a quick, easy-to-deploy, reproducible and maintainable fashion.

The emergence of powerful and inexpensive single-board computers running full versions of a standard \ac{OS} from many possible opens new possibilities in this area. This not only allows to seamlessly develop implementations that are compatible with higher end devices and allows the reuse stable software from widely-used \ac{OS}. Given this set of specific needs, in this work we present the design, key step-by-step instructions and mechanisms to setup, configurate and maintain of an inexpensive testbed using \ac{Raspi}~\cite{making_of_pi} devices for networking (wireless or wired) and storage applications including \ac{RLNC} functionalities into the testbed through Kodo. Nevertheless, the architecture itself is not bounded to the networking area and can be used for other applications that require replicable results with \ac{Raspi}~\cite{Cox2014,s141224408,s140509290,s16020220}\textcolor{red}{move citations or rewrite a bit here}. Our work for the testbed procedure is organized as follows: Section~\ref{sec:overview} introduces the testbed system. In Section~\ref{sec:image_setup}, we provide details about the testbed setup, scripts, configuration files and connectivity. In Section~\ref{sec:overlay_fs}, we elaborate on the need and setup for an overlay filesystem for our testbed in order to have both persistent and non-persistent data on it as an optional step. Section~\ref{sec:tools} describes a set of automation and monitoring tools that can be included in the testbed to simplify the execution of routinary and repetitive tasks. Section~\ref{sec:cross_compilation} elaborates on the compilation of the Kodo library for the \ac{Raspi}. Conclusions and future work are reviewed in Section~\ref{sec:conclusions}. Finally, a set of alternative commands, in case the ones presented in this work might not be executed, are discussed in the Appendices.

%%The introduction should briefly place the study in a broad context and highlight why it is important. It should define the purpose of the work and its significance. The current state of the research field should be reviewed carefully and key publications should be cited. Please highlight controversial and diverging hypotheses when necessary. Finally, briefly mention the main aim of the work and highlight the main conclusions. As far as possible, please keep the introduction comprehensible to scientists outside your particular field of research.
