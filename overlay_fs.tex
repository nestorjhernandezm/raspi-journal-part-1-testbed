\label{sec:ovelay_fs}
In principle, our procedure modifies the image file only once in
the testbed administrator \ac{PC} when its setup is made. Also, keeping
this image in the \ac{Raspi}s provides the same initial system for all
the devices. This system is later distributed locally to a memory card
in each device. However, if we do not make any further modifications during
the image setup, any files created after the initial boot of a \ac{Raspi}
will remain in the memory card. This is cumbersome to maintain since
the size of the memory card is relatively reduced (8 GB) and there
might be various users utilizing the testbed. Also, different testbed
users could be interested in running their experiments in a fresh
rebooted system with the original customized image. Nevertheless, we
emphasize that this step is not necessary if the tesbed administrator
wants to consider only persistent storage for its devices. A use case
for this scenario could be a single user for the testbed or when a testbed
administrator only wants to setup a few \ac{Raspi}s.

Therefor, if both persistent and non-persistent storage are required for
the \ac{Raspi}s, here we present the steps to setup an overlay filesystem.
This type of filesystem enables an \textit{upper} filesystem to overlay
into a \textit{lower} filesystem. Whenever a file is requested, the upper
filesystem will forward the request to the lower filesystem in case it
does not have it itself. If the upper filesystem has the requested file,
it will simpy return the file. This idea can be used in our setup to mount
the root filesystem (i.e. Raspbian lite) in the \ac{Raspi}s during startup
as read-only filesystem. Thus, on the one hand, the image configuration files
will remain after a reboot and will not be modifiable. On the other hand,
to enable the possibility of non-persistent changes, we overlay the upper
filesystem that is mounted in the \ac{Raspi} \ac{RAM}, i.e. \texttt{/tmp}
as read/writable on top of the lower root filesystem. Thus, reading a file
may return a file from the lower filesytem, but if it is stored, it will
be saved in the upper filesystem. Accessing this file again will return
the stored file from the upper layer. After a reboot, all the stored files
in the upper filesystem will be erasured.

\subsection{Overlaying Filesystem Installation}

Assuming that we are still using the \texttt{chroot} commands into the
Raspbian lite root filesystem for installing packages, we can setup the
overlay filesystem at this point of the procedure. There already exists
implementations overlaying the root filesystem. We use an implementation
available at the Git repository in \cite{overlayroot}. Since we have
installed git in a previous step, we clone the repository. The
command block below stores it in \texttt{/tmp} which is really mounted in
\ac{RAM}. Then, all the files stored here will disappear a \ac{Raspi} is
rebooted.

% Get files
\begin{lstlisting}[]
(chroot) # OVERLAYROOTDIR="/tmp/overlayroot"
(chroot) # git clone https://github.com/chesty/overlayroot.git $OVERLAYROOTDIR
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Before enabling the overlaying filesystem, it is required to generate
an initial \ac{RAM} file system or \texttt{initramfs}. This is an
initial filesystem that gets loaded into \ac{RAM} during the startup
process of a Linux machine to prepare the real filesystem. For this purpose,
we need the BusyBox package by running:

% Install required packages
\begin{lstlisting}[]
(chroot) # apt-get install busybox
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

To create and activate the overlaying filesystem, we need to first
add the required system scripts to do so. This is done as follows:

% Setup initramfs
\begin{lstlisting}[]
(chroot) # cp ${OVERLAYROOTDIR}/hooks-overlay /etc/initramfs-tools/hooks/
(chroot) # cp ${OVERLAYROOTDIR}/init-bottom-overlay /etc/initramfs-tools/scripts/init-bottom/
(chroot) # echo "overlay" > /etc/initramfs-tools/modules
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

To generate the initial \ac{RAM} filesystem, we have to utilize the
\texttt{mkinitramfs} command. This searches by default for the available
kernel modules in the system. Since we are in \texttt{chroot} mode, we need
to specify the correct kernel modules to search for. The available
kernel modules are \texttt{/lib/modules}. To see them, we just run:

% See available kernel modules
\begin{lstlisting}[]
(chroot) # ls /lib/modules/
4.4.13+  4.4.13-v7+
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
%IT SEEM THAT THE RASPIS DEMANDS DIFFERENT KERNEL MODULES AFTER ALL.
%RASP-VERSION1=4.4.13+, RASP-VERSION2=4.4.13-V7+, RASP-VERSION3=4.4.13-V7+

Now, the initial \ac{RAM} filesystem can be generated. \ac{Raspi} version 1
needs a different kernel than \ac{Raspi} version 2 and version 3. Kernel
version 4.4.13+ is for \ac{Raspi} version 1 and kernel 4.4.13-v7+ for
\ac{Raspi} version 2 and version 3. We proceed to generate an initial
\ac{RAM} filesystem for these kernels by running:

% Create an initramfs
\begin{lstlisting}[]
(chroot) # mkinitramfs -o /boot/init.gz -k 4.4.13+
(chroot) # mkinitramfs -o /boot/init-v7.gz -k 4.4.13-v7+
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Although these commands might be output some warnings, they should
successfully generate working initial \ac{RAM} filesystems. Later, an
initial \ac{RAM} filesystem will need to be called by the bootloader.
In Raspbian this is done by adding a command to \texttt{config.txt} file
in the boot partition. If the system should be run in a \ac{Raspi} version 1,
then use \texttt{init.gz}, otherwise use \texttt{init-v7.gz} as follows
\todot{What happens if I have both a Raspi 1, 2 or 3 in my testbed? Do I have
to have different images after this point?}:

%The bootloader should be made aware of the initramfs that we will generate:
\begin{lstlisting}[]
(chroot) # echo "initramfs init.gz" >> /boot/config.txt     # Only for Raspberry Pi version 1
(chroot) # echo "initramfs init-v7.gz" >> /boot/config.txt  # For Raspberry Pi version 2 or 3
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

After this point, it is no longer required to be in \texttt{chroot} mode.
The following commands exits the \texttt{chroot} environment, unmount all
partitions and detaches the loopback devices:

% Exit chroot, unmount and detach loopback devices
\begin{lstlisting}[]
(chroot) # exit
# cd ..
# umount --recursive ${ROOTDIR}
# losetup -d ${DEV}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

For the \texttt{----recursive} option to work properly, it is necessary that
the package \texttt{util-linux} version is greater than or equal to 2.22.
Otherwise, an alternative is to either update the package or follow the
procedure in Section~\ref{sec:umount} of the Appendix.

\subsection{Persistent Image Directories}
\label{sec:persistent_directories}
Provided the stacked filesystem is configured, now it is possible to have
directories where files are not removed upon rebooting the \ac{Raspi}s.
The following procedure creates an extra partition in the image for
the \ac{Raspi} user home directory that will be made storage persistent
using the upper filesystem. We first expand image according to the desired
home directory size, but avoiding to make the image bigger than the target
memory card size.

% Expand image
\begin{lstlisting}[]
$ dd if=/dev/zero bs=1M count=1024 >> ${IMAGE}.img && sync
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

We create a partition for the home directory after the root partition.
To do this, we again use \texttt{fdisk} to find the next available sector
in the image. To verify the new available space for the full image and observe
the next available sector, we run:
\begin{lstlisting}[]
$ fdisk -u sectors -l ${IMAGE}.img
Disk 2016-05-27-raspbian-jessie-lite.img: 3.3 GiB, 3534749696 bytes, 6903808 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x6fcf21f3

Device                               Boot  Start     End Sectors  Size Id Type
2016-05-27-raspbian-jessie-lite.img1        8192  137215  129024   63M  c W95 FAT32 (LBA)
2016-05-27-raspbian-jessie-lite.img2      137216 4806655 4669440  2.2G 83 Linux
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

We notice that one GB is now available to be used in the partitions. Also, we
observe the new partition should start at sector 4806656. To create it, we
show the introduced command and its output:

\begin{lstlisting}[]
$ (echo n; echo p; echo 3; echo 4806656; echo ; echo w) | fdisk ${IMAGE}.img

Command (m for help): Partition type:
   p primary (1 primary, 0 extended, 3 free)
   e extended
Partition number (1-4, default 3): Using default value 3
First sector (2048-6903807, default 2048): Last sector, +sectors or
+size{K,M,G} (4806656-6903807, default 6903807): Using default value 6903807

Command (m for help): The partition table has been altered!

Syncing disks.
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

We create again a loopback device and format the new partition, as follows:
\begin{lstlisting}[]
# export DEV=$(sudo losetup --show -f -P ${IMAGE}.img); echo $DEV
/dev/loop0
# mkfs.ext4 ${DEV}p3
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Again, if for some reason, the \texttt{-P} option is not available for
\texttt{losetup}, we provide an alternative command line in
Section~\ref{sec:alternative_losetup}. Finally, if the previous filesystem
formatting was successful, the filesystem is now available for use. Thus,
we need to inform the Raspbian root filesystem to mount the home partition
that we have just created. We will notify to the Raspbian \ac{OS} during
the startup of the \ac{Raspi}s. This can be done by adding an entry in
\texttt{fstab} as follows:

\begin{lstlisting}[]
# mount ${DEV}p2 ${ROOTDIR}
# sudo sh -c "echo '/dev/mmcblk0p3 /home ext4 defaults,noatime 0 2' >> ${ROOTDIR}/etc/fstab"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The home folder was originally located in the root filesystem. We should
therefore copy the content to the new home partition:
\begin{lstlisting}[]
# mount ${DEV}p3 ${ROOTDIR}/mnt
# mv ${ROOTDIR}/home/* ${ROOTDIR}/mnt/
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

That is it. unmount partitions and detach loop device:
\begin{lstlisting}[]
# umount --recursive ${ROOTDIR}
# losetup -d ${DEV}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\subsection{Write image to memory card}


EMPHASIZE THAT THIS SETUP IS ONLY FOR THE SETUP WHERE THE ROOT IMAGE ARE
WRITTEN TO THE MEMORY CARDS

The final step is to write the image to all the memory cards before they can
be used in the \ac{Raspi}s.

%This is done by first leaving the \texttt{chrooted}
%filesystem and unmounting all the directories we mounted:

% Exit chroot, umount, and write to memory card
%\begin{lstlisting}[]
%# exit
%# cd ..
%# umount --recursive ${ROOTDIR}
%# losetup -d ${DEV}.img
%\end{lstlisting}
%\FloatBarrier
%\vspace{-5mm}

%If successfully unmounted, you can
Insert a memory card in your machine. It will be available as
\texttt{/dev/mmcblkX} or \texttt{/dev/sdX}

%In most systems, this memory card was available under \texttt{/dev/mmcblk0}, but this may be
%different on different machines. For internal memory card readers, it will
%probably be named /dev/mmcblkX where X is some number and if the memory card
%reader is connected through \ac{USB}, then it is likely called /dev/sdX.
Make absolutely sure to write to the correct device as everything will be
overwritten!
Inserting/Ejecting the memory card a couple of times and using the commands
below may help deducing the correct device:
%The commands below may help deduce which device is the correct:
%Below is a few commands that may help you to deduce which device is correct:

\begin{lstlisting}[]
# lsblk
# df -h
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

For us, the device was \texttt{/dev/mmcblk0}. Write the image to a memory card:
\begin{lstlisting}[]
# dd if=${IMAGE}.img of=/dev/mmcblk0 bs=4M && sync
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The memory card can now be started in a \ac{Raspi}.