\label{sec:testbed_http}
Creating manual copies of the customized image for each memory card can
be also a time-consuming task that is prone to errors and become
cumbersome. Therefore, we present an optional more advanced \ac{HTTP}
image fetching setup for the existing image to be downloaded from a
\ac{HTTP} server. We consider this an optional step since a testbed
administrator might opt for not including this as part of his / her setup.
We start our description consideri

At the end of Section~\ref{sec:overlay_fs}, the final customized image was
proposed to be splitted into three partitions. One for the boot files, one
containing the root file system and one for the home directory. This is made
considering an overlay filesystem approach. In this section, instead of
working with three partitions and writing the image directly to the memory
cards, we present how to configure the boot partition to download the root
filesystem partition and also configure the home directory partitions
from a \ac{HTTP} server during startup. The advantage of this setup is that
we completely automate the image fetch which significantly eases its
maintainance since any changes are required to be made only in the \ac{HTTP}
server image. We start by declaring the variables for the path names of each
partition:

\begin{lstlisting}[]
$ export HTTPBOOTIMAGE="${WORKDIR}/httpboot"
$ export HTTPROOTIMAGE="${WORKDIR}/httproot"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Then, we setup a loopback device of the existing image and use \texttt{dd} to
extract the boot and root partitions from the image:
\begin{lstlisting}[]
# export DEV=$(sudo losetup --show -f -P ${IMAGE}.img); echo $DEV
# dd if=${DEV}p1 of=${HTTPBOOTIMAGE}.img bs=4M
# dd if=${DEV}p2 of=${HTTPROOTIMAGE}.img bs=4M
# losetup -d ${DEV}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now it is time to configure the boot- and root-image just extracted before
the content of the boot image is copied to the a memory card and the root
image is uploaded to a \ac{HTTP} server.

Create a mountpoint and mount the http root and boot images:
%Mount the http root image and home directories
\begin{lstlisting}[]
$ export HTTPROOTDIR="${WORKDIR}/httproot"
$ mkdir -p ${HTTPROOTDIR}
# mount -o loop ${HTTPROOTIMAGE}.img ${HTTPROOTDIR}
# mount -o loop ${HTTPBOOTIMAGE}.img ${HTTPROOTDIR}/boot
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

In a previous steps, the boot loader was configured to call an initial \ac{RAM}
filesystem. Now, we present how to the initial \ac{RAM}
filesystem can be extended further to download and cache the root filesystem
from a \ac{HTTP} server before mounting it.

The initial \ac{RAM} filesystem contains an \texttt{init} script that
is first called to initializes
\texttt{initramfs}, parse arguments specified in \texttt{cmdline.txt}, and
call a specialized script that prepares the actual root filesystem. By default,
Raspbian includes scripts to mount the root filesystem from 1) a block devices
(i.e. the memory card) and 2) from a \ac{NFS} shared folder. We make a third
script to mount the root filesystem from an image
(i.e. the root image \texttt{httproot.img}) that is downloaded from a
\ac{HTTP} server.

The initramfs script to download and mount the image from a \ac{HTTP} server
will require a few additional arguments. E.g. to specify from which \ac{HTTP}
server to download the root filesystem image from.
%This script that we will create will require a few additional arguments such
%as which \ac{HTTP} server the image should be downloaded from.
These arguments
may be specified in \texttt{cmdline.txt}.
%and later parsed within the \texttt{initramfs} script.

Keep the content in \texttt{cmdline.txt}, but add/modify the variables
\texttt{boot}, \texttt{ip}, \texttt{image}, \texttt{root}, and \texttt{url}.

%Keep also all other variables as they are in
%\texttt{cmdline.txt}.

%Add the below configurations to \$\{HTTPROOTDIR\}/boot/cmdline.txt
\textcolor{red}{(remove init=/usr/lib/raspi-config/init\_resize.sh earlier in guide)}
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/boot/cmdline.txt}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
<@\Suppressnumber @>boot=http ip=dhcp image=/dev/mmcblk0p2:/httproot.img root=/dev/loop0
    url=http://kom.aau.dk/project/TuneSCode/raspi/<@\Reactivatenumber @>
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
% ip=dhcp root=/dev/http http-options=hard,intr,ro

Here is how the variables will be used in the \texttt{initramfs}:
\begin{itemize}
    \item boot=http: tells the init script in initramfs to call the \texttt{http} script that will be presented below
    \item ip=dhcp: use \ac{DHCP} to obtain an \ac{IP} address in the \texttt{initramfs}
    \item image=<device>:<root image path>: is where the \ac{Raspi} will store the downloaded root image.
    \item root=/dev/loop0: The \texttt{http} initramfs script will make the root filesystem available on /dev/loop0
    \item url=<URL to root image>: Is the directory on a \ac{HTTP} server where the root image will be iavailable.
\end{itemize}


%The \ac{URL} should be modified to reflect where
%the \ac{Raspi}s should download the http root image. The \texttt{image} variable informs the
%\texttt{http} initramfs script to download and cache the http root image in the second partition
%on its memory card at path \texttt{/httproot.img}.




The specialized script that we made to download and mount the root filesystem image from a \ac{HTTP} server should be created in the root filesystem as presented below:
%Create the following file
\textcolor{red}{(THE READ-ONLY OPTION IS STILL NOT CONFIGURABLE IN THIS SCRIPT. I'M NOT EVEN SURE IT IS POSSIBLE TO MAKE THE IMAGE READ-WRITABLE)}
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/initramfs-tools/scripts/http}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
# Fetch, cache, and mount root image using HTTP

# Create mount point directory
[ -d /imagedir ] || mkdir /imagedir

# Parse additional command line options
for x in $(cat /proc/cmdline); do
    case $x in
    image=*)
        IMAGE=${x#image=}
        # Extract device and path
        # E.g. /dev/mmcblkp2:/root.img --> /dev/mmcblkp2 and /imagedir/root.img
        IMAGEDEV=${IMAGE%:*}
        IMAGEPATH="${IMAGE#*:}"
        IMAGEPATH="/imagedir/${IMAGEPATH#/}"
        ;;
    url=*)
        URL=${x#url=}
        URL=${URL%/}  # If url has trailing slash, then remove it
        ;;
    esac
done

# Check if variables are declared
[ -z "${IMAGE}" ] && echo "Error: Please add 'image' in cmdline.txt" && exit 1
[ -z "${URL}" ] && echo "Error: Please add 'url' in cmdline.txt" && exit 1

# Fetch and cache root image
http_fetch_image()
{
    configure_networking

    # Fetch list of root image names
    if ! wget -O /tmp/image.csv "${URL}/image.csv"; then
        echo "WARNING failed to fetch image list"
        return
    fi

    # Extract name of image to download based on eth0 MAC
    mac=$(cat /sys/class/net/eth0/address)
    img=$(grep $mac /tmp/image.csv | cut -f2 -d' ')

    # If the image is not cached, then get it
    if [ ! -f "${IMAGEPATH%/*}/${img}" ] && wget --spider -q "${URL}/${img}"; then
        # Delete old image
        rm -f $(readlink -f ${IMAGEPATH})

        # Fetch new image
        if wget -O "${IMAGEPATH%/*}/${img}" "${URL}/${img}"; then
            # If success, create symbolic link to new image
            ln -f -s "${IMAGEPATH%/*}/${img}" ${IMAGEPATH}
        fi
    fi

    # Cleanup
    #rm /tmp/image.csv
}

http_mount_root()
{
    modprobe ext4

    # Mount imagedir
    #mount -n -t ext4 ${IMAGEDEV} /${${IMAGEPATH#/}%%/*}
    mount -n -t ext4 ${IMAGEDEV} /imagedir

    # Fetch and cache root image
    http_fetch_image

    # Mount root as readonly
    losetup /dev/loop0 $(readlink -f ${IMAGEPATH})
    mount -r -n -t ext4 -o nodiratime,noatime /dev/loop0 /root
}

mountroot()
{
    http_mount_root
}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Make the script executable
\begin{lstlisting}[]
# chmod +x ${HTTPROOTDIR}/etc/initramfs-tools/scripts/http
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

The variable (boot=http) that we specified in \texttt{cmdline.txt} tells the
\texttt{init} script to call the script above rather than the default scripts
that mounts the root filesystem from a block device or a \ac{NFS} shared
folder. The \texttt{init} script will call the function \texttt{http\_mount\_root}
which in this case can be consired as the \texttt{main} function.

As in any other shell scripts, this means that code in the global namespace
will be executed by the interpretor before the function \texttt{http\_mount\_root}
is entered.
%Due to the variable that we specified in \texttt{cmdline.txt},
Hence, line 9 will be the first command executed. This line creates a directory
in \texttt{initramfs} named
\texttt{imagedir} that we will use to hold the root image.

Next, line 12 to line 44 will parse the additional arguments that we provided in
\texttt{cmdline.txt}.


The \ac{Raspi}s does not have enough \ac{RAM} to hold entire root
filesystem, so we instead download it to the partition that, as specified in
\texttt{fstab} later, will later be mounted as the \texttt{HOME} directory
when the system starts. This will enable the \ac{Raspi}s to cache the root image
and use the previously downloaded root image again after reboots (see the
function \texttt{http\_fetch\_image} starting from line 56)\fxnote{is there a better way to reference to a function within the script? This reference will be invalid if the script is slightly modified}.




Edit fstab to look like this (exclude the last line if a persistent
home storage directory is not desired):
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/fstab}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
proc            /proc           proc    defaults          0       0
/dev/mmcblk0p1  /boot           vfat    defaults          0       2
/dev/loop0      /               ext4    defaults,noatime  0       1
/dev/mmcblk0p2  /home           ext4    defaults,noatime  0       0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Chroot into the image
% CHROOT to OS image
\begin{lstlisting}[]
$ cd $HTTPROOTDIR
# mount -t proc proc proc/
# mount --bind /sys sys/
# mount --bind /dev dev/
# mount --bind /dev/pts dev/pts
# proot -q qemu-arm-static -S ${HTTPROOTDIR}
# export PS1="(chroot) $PS1"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Create new initramfs (remember that your kernel might be different)
\begin{lstlisting}[]
(chroot) # mkinitramfs -o /boot/init.gz -k 4.4.13+
(chroot) # mkinitramfs -o /boot/init-v7.gz -k 4.4.13-v7+
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Exit chroot
\begin{lstlisting}[]
(chroot) # exit
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Unmount:
\begin{lstlisting}[]
$ cd ..
# umount ${HTTPROOTIMAGE}/{dev/pts,proc,sys,dev}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsubsection{Prepare sd-card}

IS SETTING UP THE SD-CARD REALLY THE SAME PROCEDURE AS FOR A LOCAL FILESYSTEM?

% Define variable
% export IMAGE="2016-05-27-raspbian-jessie-lite"
% export WORKDIR="${HOME}/Raspbian"
\begin{lstlisting}[]
$ export HTTPDEV="/dev/mmcblk0"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

MAYBE ALSO SET THE BOOT FLAG FOR FIRST PARTITION. ALSO UPDATE SCRIPT IF THIS
WORKS. THERE MAY HAVE TO BE ECHOED A 1 AFTER echo a FOR SETTING BOOT FLAG
\begin{lstlisting}[]
<@\Suppressnumber @># (echo o;                                      # Create DOS partition table
    echo n; echo p; echo 1; echo ; echo +64M;   # Create boot partition
    echo t; echo b;                             # Set boot partition type to FAT
    echo a;                                     # Set boot flag
    echo n; echo p; echo 2; echo ; echo ;       # Create home partition
    echo w                                      # Write table to disk
    ) | sudo fdisk ${HTTPDEV} <@\Reactivatenumber @>
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Print partition table (SHOULD THE BOOT FLAG HAVE BEEN SET TO PARTITION P1?)
\begin{lstlisting}[]
# fdisk -u sectors -l ${HTTPDEV}
Disk /dev/mmcblk0: 3.7 GiB, 3965190144 bytes, 7744512 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00e61b04

Device         Boot  Start     End Sectors  Size Id Type
/dev/mmcblk0p1        2048  133119  131072   64M  b W95 FAT32
/dev/mmcblk0p2      133120 7744511 7611392  3.6G 83 Linux
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Format partitions
\begin{lstlisting}[]
# mkfs.vfat -n BOOT ${HTTPDEV}p1
# mkfs.ext4 -L HOME ${HTTPDEV}p2
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}






Mount the boot partition from the memory card. Copy the content from the
boot image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p1 ${HTTPROOTDIR}/mnt
# cp -rp ${HTTPROOTDIR}/boot/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Mount the home partition from the memory card. Copy the content from the
root image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p2 ${HTTPROOTDIR}/mnt
# cp -rp ${HTTPROOTDIR}/home/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\begin{lstlisting}[]
# umount --recursive ${HTTPROOTDIR}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsubsection{(Optional) Compressing root image}

PROBABLY A BETTER IDEA TO USE BTRFS TRANSPARENT COMPRESSION

\begin{lstlisting}[]
# apt-get install squashfs-tools
# mount -o loop ${HTTPROOTIMAGE}.img ${HTTPROOTDIR}
# mksquashfs ${HTTPROOTDIR} compressed_${HTTPROOTIMAGE}.img
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\subsubsection{Try it out}

Upload the root image (\$\{HTTPROOTIMAGE\}.img) to the HTTP server used in the
configurations above. Then, unplug the memory card from the computer.
Insert it into a \ac{Raspi} and
turn it on. It is recommended that the \ac{Raspi} is turned on with a monitor
connected the first time the newly created Linux installation is tested to
assure that Raspbian starts up correctly.


PRESENT FILES ON HTTP. E.G. HTTPROOT.IMG AND IMAGES.CSV


\begin{itemize}
    \item Copy http root image (\$\{HTTPROOTIMAGE\}.img) a HTTP server
    \item Create images.csv
\end{itemize}


\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{http://<SERVERIP>/.../images.csv}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
# Ethernet MAC    Root image
b8:27:eb:5b:da:20 httproot_1.img
b8:27:eb:7b:c3:91 httproot_1.img
b8:27:eb:7b:c3:91 httproot_2.img
...
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Notice that the \ac{Raspi}s can be configured to download different root images.
This is useful both for having various root images for subsets of the \ac{Raspi}s,
but also as a basic way inform the \ac{Raspi}s that the root image changed such
that they can download the new root image at next boot.

As of this writing, there is unfortunately a bug in wget that makes wget not showing
its progress bar while downloading the root image at startup. Instead, it may appear
to be unable to connect although it is downloading, so keep patient.

\begin{lstlisting}[]
Connecting to <HTTP SERVER IP> (<HTTP SERVER IP>:<PORT>)
image.csv       100% |*******************************************************| 1287   0:00:00 ETA
Connecting to <HTTP SERVER IP> (<HTTP SERVER IP>:<PORT>)
_
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


REMEMBER TO COPY-PASTE ALL CONTENT FROM SCRIPT INTO LATEX AGAIN IN CASE SOME
SCRIPT CHANGED, BUT WAS NOT UPDATED IN LATEX
