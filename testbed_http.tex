\label{sec:testbed_http}
Creating manual copies of the customized image for each memory card can
be also a time-consuming task that is prone to errors and become
cumbersome. Therefore, we present an optional more advanced \ac{HTTP}
image fetching setup for the existing image to be downloaded from a
\ac{HTTP} server. We consider this an optional step since a testbed
administrator might opt for not including this as part of his / her setup.

At the end of Section~\ref{sec:overlay_fs}, the final customized image was
proposed to be splitted into three partitions. One for the boot files, one
containing the root file system and one for the home directory. This is made
considering an overlay filesystem approach. In this section, instead of
writing the image directly to the memory cards, we present how the
partitions can be extracted from the image, and how the boot partition can
be configured to download the root filesystem and home directory partitions
from a \ac{HTTP} server during startup. The advantage of this setup is that
we completely automate the image fetch which significantly eases its
maintainance since any changes are required to be made only in the \ac{HTTP}
server image. We start by declaring the variables for the path names of each
partition:

\begin{lstlisting}[]
$ export HTTPBOOTIMAGE="${WORKDIR}/httpboot"
$ export HTTPROOTIMAGE="${WORKDIR}/httproot"
$ export HTTPHOMEIMAGE="${WORKDIR}/httphome"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

We set loopback devices for each of the image partitions and use \texttt{dd} to
extract them from the image:
\begin{lstlisting}[]
# export DEV=$(sudo losetup --show -f -P ${IMAGE}.img); echo $DEV
# dd if=${DEV}p1 of=${HTTPBOOTIMAGE}.img bs=4M
# dd if=${DEV}p2 of=${HTTPROOTIMAGE}.img bs=4M
# dd if=${DEV}p3 of=${HTTPHOMEIMAGE}.img bs=4M
# losetup -d ${DEV}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Now, we configure each of these partitions. The content of the boot image is
copied and modified just once into a memory card and the root
and home images is uploaded to a \ac{HTTP} server. Even though we still
have to manually configure and set the memory cards, we only have
to make this one time, since the \ac{Raspi}s will fetch the root filesystem
from the \ac{HTTP} server every they are turned on.

Create a mountpoint and mount the http root and boot images:
%Mount the http root image and home directories
\begin{lstlisting}[]
$ export HTTPROOTDIR="${WORKDIR}/httproot"
$ mkdir -p ${HTTPROOTDIR}
# mount -o loop ${HTTPROOTIMAGE}.img ${HTTPROOTDIR}
# mount -o loop ${HTTPBOOTIMAGE}.img ${HTTPROOTDIR}/boot
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

In a previous steps, the boot loader was configured to call an initial \ac{RAM}
filesystem. Now, we present how to the initial \ac{RAM}
filesystem can be extended further to download and cache the root filesystem
from a \ac{HTTP} server before mounting it.

The initial \ac{RAM} filesystem contains an \texttt{init} script that
sets up the prepares the yis first
called. This script initializes the  may be rewritten, but

Create the following file (THE READ-ONLY OPTION IS STILL NOT CONFIGURABLE IN THIS SCRIPT)
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/initramfs-tools/scripts/http}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
# Fetch, cache, and mount root image using HTTP

# Create mount point directory
[ -d /imagedir ] || mkdir /imagedir

# Parse additional command line options
for x in $(cat /proc/cmdline); do
    case $x in
    image=*)
        IMAGE=${x#image=}
        # Extract device and path
        # E.g. /dev/mmcblkp2:/root.img --> /dev/mmcblkp2 and /imagedir/root.img
        IMAGEDEV=${IMAGE%:*}
        IMAGEPATH="${IMAGE#*:}"
        IMAGEPATH="/imagedir/${IMAGEPATH#/}"
        ;;
    url=*)
        URL=${x#url=}
        URL=${URL%/}  # If url has trailing slash, then remove it
        ;;
    esac
done

# Check if variables are declared
[ -z "${IMAGE}" ] && echo "Error: Please add 'image' in cmdline.txt" && exit 1
[ -z "${URL}" ] && echo "Error: Please add 'url' in cmdline.txt" && exit 1

# Fetch and cache root image
http_fetch_image()
{
    configure_networking

    # Fetch list of root image names
    if ! wget -O /tmp/image.csv "${URL}/image.csv"; then
        echo "WARNING failed to fetch image list"
        return
    fi

    # Extract name of image to download based on eth0 MAC
    mac=$(cat /sys/class/net/eth0/address)
    img=$(grep $mac /tmp/image.csv | cut -f2 -d' ')

    # If the image is not cached, then get it
    if [ ! -f "${IMAGEPATH%/*}/${img}" ] && wget --spider -q "${URL}/${img}"; then
        # Delete old image
        rm -f $(readlink -f ${IMAGEPATH})

        # Fetch new image
        if wget -O "${IMAGEPATH%/*}/${img}" "${URL}/${img}"; then
            # If success, create symbolic link to new image
            ln -f -s "${IMAGEPATH%/*}/${img}" ${IMAGEPATH}
        fi
    fi

    # Cleanup
    #rm /tmp/image.csv
}

http_mount_root()
{
    modprobe ext4

    # Mount imagedir
    #mount -n -t ext4 ${IMAGEDEV} /${${IMAGEPATH#/}%%/*}
    mount -n -t ext4 ${IMAGEDEV} /imagedir

    # Fetch and cache root image
    http_fetch_image

    # Mount root as readonly
    losetup /dev/loop0 $(readlink -f ${IMAGEPATH})
    mount -r -n -t ext4 -o nodiratime,noatime /dev/loop0 /root

    # Bind /root/home to /home
    #mount -n -o rbind /home /root/home
}

mountroot()
{
    http_mount_root
}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Make the script executable
\begin{lstlisting}[]
# chmod +x ${HTTPROOTDIR}/etc/initramfs-tools/scripts/http
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Keep the content in \texttt{cmdline.txt}, but add/modify the variables
\texttt{boot}, \texttt{ip}, \texttt{image}, \texttt{root}, and \texttt{url}.

%Keep also all other variables as they are in
%\texttt{cmdline.txt}.

%Add the below configurations to \$\{HTTPROOTDIR\}/boot/cmdline.txt
(remove init=/usr/lib/raspi-config/init\_resize.sh earlier in guide)
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/boot/cmdline.txt}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
<@\Suppressnumber @>boot=http ip=dhcp image=/dev/mmcblk0p2:/httproot.img root=/dev/loop0
    url=http://kom.aau.dk/project/TuneSCode/raspi/<@\Reactivatenumber @>
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
% ip=dhcp root=/dev/http http-options=hard,intr,ro

Here is how the variables are used in the initramfs:
\begin{itemize}
    \item boot=http: tells the init script in initramfs to call the \texttt{http} script presented above
    \item ip=dhcp: use \ac{DHCP} to obtain an \ac{IP} address in the initial ram filesystem
    \item image=<device>:<root image path>: is where the \ac{Raspi} will store the downloaded root image.
    \item root=/dev/loop0: The \texttt{http} initramfs script will make the root filesystem available on /dev/loop0
    \item url=<URL to root image>: Is the directory on a \ac{HTTP} server where the root image will be iavailable.
\end{itemize}


%The \ac{URL} should be modified to reflect where
%the \ac{Raspi}s should download the http root image. The \texttt{image} variable informs the
%\texttt{http} initramfs script to download and cache the http root image in the second partition
%on its memory card at path \texttt{/httproot.img}.



Edit fstab to look like this (exclude the last line if a persistent
home storage directory is not desired):
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/fstab}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
proc            /proc           proc    defaults          0       0
/dev/mmcblk0p1  /boot           vfat    defaults          0       2
/dev/loop0      /               ext4    defaults,noatime  0       1
/dev/mmcblk0p2  /home           ext4    defaults,noatime  0       0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Chroot into the image
% CHROOT to OS image
\begin{lstlisting}[]
$ cd $HTTPROOTDIR
# mount -t proc proc proc/
# mount --bind /sys sys/
# mount --bind /dev dev/
# mount --bind /dev/pts dev/pts
# proot -q qemu-arm-static -S ${HTTPROOTDIR}
# export PS1="(chroot) $PS1"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Create new initramfs (remember that your kernel might be different)
\begin{lstlisting}[]
(chroot) # mkinitramfs -o /boot/init.gz -k 4.4.13+
(chroot) # mkinitramfs -o /boot/init-v7.gz -k 4.4.13-v7+
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Exit chroot
\begin{lstlisting}[]
(chroot) # exit
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Unmount:
\begin{lstlisting}[]
$ cd ..
# umount ${HTTPROOTIMAGE}/{dev/pts,proc,sys,dev}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsection{Prepare sd-card}

IS SETTING UP THE SD-CARD REALLY THE SAME PROCEDURE AS FOR A LOCAL FILESYSTEM?

% Define variable
% export IMAGE="2016-05-27-raspbian-jessie-lite"
% export WORKDIR="${HOME}/Raspbian"
\begin{lstlisting}[]
$ export HTTPDEV="/dev/mmcblk0"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

MAYBE ALSO SET THE BOOT FLAG FOR FIRST PARTITION. ALSO UPDATE SCRIPT IF THIS
WORKS. THERE MAY HAVE TO BE ECHOED A 1 AFTER echo a FOR SETTING BOOT FLAG
\begin{lstlisting}[]
<@\Suppressnumber @># (echo o;                                      # Create DOS partition table
    echo n; echo p; echo 1; echo ; echo +64M;   # Create boot partition
    echo t; echo b;                             # Set boot partition type to FAT
    echo a;                                     # Set boot flag
    echo n; echo p; echo 2; echo ; echo ;       # Create home partition
    echo w                                      # Write table to disk
    ) | sudo fdisk ${HTTPDEV} <@\Reactivatenumber @>
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Print partition table (SHOULD THE BOOT FLAG HAVE BEEN SET TO PARTITION P1?)
\begin{lstlisting}[]
# fdisk -u sectors -l ${HTTPDEV}
Disk /dev/mmcblk0: 3.7 GiB, 3965190144 bytes, 7744512 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00e61b04

Device         Boot  Start     End Sectors  Size Id Type
/dev/mmcblk0p1        2048  133119  131072   64M  b W95 FAT32
/dev/mmcblk0p2      133120 7744511 7611392  3.6G 83 Linux
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Format partitions
\begin{lstlisting}[]
# mkfs.vfat -n BOOT ${HTTPDEV}p1
# mkfs.ext4 -L HOME ${HTTPDEV}p2
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}






Mount the boot partition from the memory card. Copy the content from the
boot image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p1 ${HTTPROOTDIR}/mnt
# cp -rp ${HTTPROOTDIR}/boot/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Mount the home partition from the memory card. Copy the content from the
root image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p2 ${HTTPROOTDIR}/mnt
# cp -rp ${HTTPROOTDIR}/home/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\begin{lstlisting}[]
# umount --recursive ${HTTPROOTDIR}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsection{Compressing root image (Optional)}

PROBABLY A BETTER IDEA TO USE BTRFS TRANSPARENT COMPRESSION

\begin{lstlisting}[]
# apt-get install squashfs-tools
# mount -o loop ${HTTPROOTIMAGE}.img ${HTTPROOTDIR}
# mksquashfs ${HTTPROOTDIR} compressed_${HTTPROOTIMAGE}.img
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\subsection{Try it out}

Upload the root image (\$\{HTTPROOTIMAGE\}.img) to the HTTP server used in the
configurations above. Then, unplug the memory card from the computer.
Insert it into a \ac{Raspi} and
turn it on. It is recommended that the \ac{Raspi} is turned on with a monitor
connected the first time the newly created Linux installation is tested to
assure that Raspbian starts up correctly.


PRESENT FILES ON HTTP. E.G. HTTPROOT.IMG AND IMAGES.CSV


\begin{itemize}
    \item Copy http root image (\$\{HTTPROOTIMAGE\}.img) a HTTP server
    \item Create images.csv
\end{itemize}


\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{http://<SERVERIP>/.../images.csv}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
# Ethernet MAC    Root image
b8:27:eb:5b:da:20 httproot_1.img
b8:27:eb:7b:c3:91 httproot_1.img
b8:27:eb:7b:c3:91 httproot_2.img
...
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Notice that the \ac{Raspi}s can be configured to download different root images.
This is useful both for having various root images for subsets of the \ac{Raspi}s,
but also as a basic way inform the \ac{Raspi}s that the root image changed such
that they can download the new root image at next boot.

As of this writing, there is unfortunately a bug in wget that makes wget not showing
its progress bar while downloading the root image at startup. Instead, it may appear
to be unable to connect although it is downloading, so keep patient.

\begin{lstlisting}[]
Connecting to <HTTP SERVER IP> (<HTTP SERVER IP>:<PORT>)
image.csv       100% |*******************************************************| 1287   0:00:00 ETA
Connecting to <HTTP SERVER IP> (<HTTP SERVER IP>:<PORT>)
_
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


REMEMBER TO COPY-PASTE ALL CONTENT FROM SCRIPT INTO LATEX AGAIN IN CASE SOME
SCRIPT CHANGED, BUT WAS NOT UPDATED IN LATEX
