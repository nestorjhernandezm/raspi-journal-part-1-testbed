\label{sec:testbed_http}


\subsection{HTTP}


\begin{lstlisting}[]
$ export HTTPBOOTIMAGE="${WORKDIR}/httpboot"
$ export HTTPROOTIMAGE="${WORKDIR}/httproot"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Extract root partition from image
\begin{lstlisting}[]
# export DEV=$(sudo losetup --show -f -P ${IMAGE}.img); echo $DEV
# dd if=${DEV}p1 of=${HTTPBOOTIMAGE}.img bs=4M
# dd if=${DEV}p2 of=${HTTPROOTIMAGE}.img bs=4M
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Mount http root and home directories (ADD LOOP OPTION HERE WHEN MOUNTING)
\begin{lstlisting}[]
$ export HTTPROOTDIR="${WORKDIR}/httproot"
$ mkdir -p ${HTTPROOTDIR}
# mount ${HTTPROOTIMAGE}.img ${HTTPROOTDIR}
# mount ${HTTPBOOTIMAGE}.img ${HTTPROOTDIR}/boot
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Create the following file (THE READ-ONLY OPTION IS STILL NOT CONFIGURABLE IN THIS SCRIPT)
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/initramfs-tools/scripts/http}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
# Fetch, cache, and mount root image using HTTP

#. /scripts/functions # Already loaded in the init script

# Create mount point directory
[ -d /imagedir ] || mkdir /imagedir

# Parse additional command line options
for x in $(cat /proc/cmdline); do
    case $x in
    image=*)
        IMAGE=${x#image=}
        # Extract device and path
        # E.g. /dev/mmcblkp2:/root.img --> /dev/mmcblkp2 and /imagedir/root.img
        IMAGEDEV=${IMAGE%:*}
        IMAGEPATH="${IMAGE#*:}"
        IMAGEPATH="/imagedir/${IMAGEPATH#/}"
        ;;
    url=*)
        URL=${x#url=}
        URL=${URL%/}  # If url has trailing slash, then remove it
        ;;
    esac
done

# Check if variables are declared
[ -z "${IMAGE}" ] && echo "Error: Please add 'image' in cmdline.txt" && exit 1
[ -z "${URL}" ] && echo "Error: Please add 'url' in cmdline.txt" && exit 1

# Fetch and cache root image
http_fetch_image()
{
    configure_networking

    # Fetch list of root image names
    if ! wget -O /tmp/image.csv "${URL}/image.csv"; then
        echo "WARNING failed to fetch image list"
        return
    fi

    # Extract name of image to download based on eth0 MAC
    mac=$(cat /sys/class/net/eth0/address)
    img=$(grep $mac /tmp/image.csv | cut -f2 -d' ')

    # If the image is not cached, then get it
    if [ ! -f ${img} ] && wget --spider -q "${URL}/${img}"; then
        # Delete old image
        rm -f $(readlink -f ${IMAGEPATH})

        # Fetch new image
        if wget -O "${IMAGEPATH%/*}/${img}" "${URL}/${img}"; then
            # If success, create symbolic link to new image
            ln -f -s "${IMAGEPATH%/*}/${img}" ${IMAGEPATH}
        fi
    fi

    # Cleanup
    #rm /tmp/image.csv
}

http_mount_root()
{
    modprobe ext4

    # Mount imagedir
    #mount -n -t ext4 ${IMAGEDEV} /${${IMAGEPATH#/}%%/*}
    mount -n -t ext4 ${IMAGEDEV} /imagedir

    # Fetch and cache root image
    http_fetch_image

    # Mount root as readonly
    losetup /dev/loop0 $(readlink -f ${IMAGEPATH})
    mount -r -n -t ext4 -o nodiratime,noatime /dev/loop0 /root

    # Bind /root/home to /home
    #mount -n -o rbind /home /root/home
}

mountroot()
{
    http_mount_root
}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Make the script executable
\begin{lstlisting}[]
# chmod +x ${HTTPROOTDIR}/etc/initramfs-tools/scripts/http
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Add the below to \$\{HTTPROOTDIR\}/boot/cmdline.txt (CHANGE URL HERE) (remove init=/usr/lib/raspi-config/init\_resize.sh earlier in guide)
\begin{lstlisting}[]
boot=http ro ip=dhcp image=/dev/mmcblk0p2:/root.img root=/dev/loop0 url=http://192.168.87.106/raspi/
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}
% ip=dhcp root=/dev/http http-options=hard,intr,ro


Edit fstab to look like this (exclude the last line if persistent
home storage directory is not desired):
\Suppressnumber\begin{lstlisting}[]
<@\textcolor{gray}{\$\{HTTPROOTDIR\}/etc/fstab}@>
<@\textcolor{gray}{
---------------------------------------------------------------}
\Reactivatenumber @>
proc            /proc           proc    defaults          0       0
/dev/mmcblk0p1  /boot           vfat    defaults          0       2
/dev/loop0      /               ext4    defaults,noatime  0       1
/dev/mmcblk0p2  /home           ext4    defaults,noatime  0       0
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Chroot into the image
% CHROOT to OS image
\begin{lstlisting}[]
$ cd $HTTPROOTDIR
# mount -t proc proc proc/
# mount --bind /sys sys/
# mount --bind /dev dev/
# mount --bind /dev/pts dev/pts
# proot -q qemu-arm-static -S ${HTTPROOTDIR}
# export PS1="(chroot) $PS1"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


Create new initramfs (remember that your kernel might be different)
\begin{lstlisting}[]
(chroot) # mkinitramfs -o /boot/init.gz -k 4.4.11+
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Exit chroot
\begin{lstlisting}[]
(chroot) # exit
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Unmount:
\begin{lstlisting}[]
# umount ${HTTPROOTIMAGE}/{dev/pts,proc,sys,dev}  
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsubsection{Prepare sd-card}

IS SETTING UP THE SD-CARD REALLY THE SAME PROCEDURE AS FOR A LOCAL FILESYSTEM?

% Define variable
% export IMAGE="2016-05-27-raspbian-jessie-lite"
% export WORKDIR="${HOME}/Raspbian"
\begin{lstlisting}[]
$ export HTTPDEV="/dev/mmcblk0"
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

MAYBE ALSO SET THE BOOT FLAG FOR FIRST PARTITION. ALSO UPDATE SCRIPT IF THIS
WORKS. THERE MAY HAVE TO BE ECHOED A 1 AFTER echo a FOR SETTING BOOT FLAG
\begin{lstlisting}[]
<@\Suppressnumber @># (echo o;                                      # Create DOS partition table
    echo n; echo p; echo 1; echo ; echo +64M;   # Create boot partition
    echo t; echo b;                             # Set boot partition type to FAT
    echo a;                                     # Set boot flag
    echo n; echo p; echo 2; echo ; echo ;       # Create home partition
    echo w                                      # Write table to disk
    ) | sudo fdisk ${HTTPDEV} <@\Reactivatenumber @>
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Print partition table (SHOULD THE BOOT FLAG HAVE BEEN SET TO PARTITION P1?)
\begin{lstlisting}[]
# fdisk -u sectors -l ${HTTPDEV}
Disk /dev/mmcblk0: 3.7 GiB, 3965190144 bytes, 7744512 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x00e61b04

Device         Boot  Start     End Sectors  Size Id Type
/dev/mmcblk0p1        2048  133119  131072   64M  b W95 FAT32
/dev/mmcblk0p2      133120 7744511 7611392  3.6G 83 Linux
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Format partitions
\begin{lstlisting}[]
# mkfs.vfat -n BOOT ${HTTPDEV}p1
# mkfs.ext4 -L HOME ${HTTPDEV}p2
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}






Mount the boot partition from the memory card. Copy the content from the
boot image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p1 ${HTTPROOTDIR}/mnt
# cp -r ${HTTPROOTDIR}/boot/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

Mount the home partition from the memory card. Copy the content from the
root image and unmount it again:
\begin{lstlisting}[]
# mount ${HTTPDEV}p2 ${HTTPROOTDIR}/mnt
# cp -r ${HTTPROOTDIR}/home/* ${HTTPROOTDIR}/mnt/ && sync
# umount ${HTTPROOTDIR}/mnt
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\begin{lstlisting}[]
# umount --recursive ${HTTPROOTDIR}
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}


\subsubsection{(Optional) Compressing root image}

PROBABLY A BETTER IDEA TO USE BTRFS TRANSPARENT COMPRESSION

\begin{lstlisting}[]
# apt-get install squashfs-tools
# mount -o loop ${HTTPROOTIMAGE}.img ${HTTPROOTDIR} 
# mksquashfs ${HTTPROOTDIR} compressed_${HTTPROOTIMAGE}.img       
\end{lstlisting}
\FloatBarrier
\vspace{-5mm}

\subsubsection{Try it out}

Upload the root image (\$\{HTTPROOTIMAGE\}.img) to the HTTP server used in the
configurations above. Then, unplug the memory card from the computer.
Insert it into a \ac{Raspi} and
turn it on. It is recommended that the \ac{Raspi} is turned on with a monitor
connected the first time the newly created Linux installation is tested to
assure that Raspbian starts up correctly.


PRESENT FILES ON HTTP. E.G. HTTPROOT.IMG AND IMAGES.CSV



